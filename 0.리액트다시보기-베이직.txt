[INDEX]================================================================================================================================

<기본>

0. 시작은 npm start
1. src 안에, components 폴더를 만들어, component 를 만든다.
2. component 의 이름은, 첫글자는 대문자이여야한다.
3. 결국 붙여지는 곳은 메인 "App.js" 이다.
4. 해당 컴포넌트만 적용받는, 기본 스타일링은 .module.css이다.
5. 그냥 css 를 사용하면, "묶인 컴포넌트 전체가 바뀐다." 클래스네임을 확실히 지정할거면 이게 더 편하다
6. className 에서 _ 는 허용한다.
7. class 는 className 이다.
8. props 넣는 것도 똑같다.
9. wrapper 로 감싸는 것(Layout or Card) 도 똑같다.
10. 컴포넌트 함수를 "표현식인 화살표 함수로 만들 수도 있는 것도 같다".

<차이점>

1. 페이지의 유무

<설정>

1. but never use 에러 없애기


<이론>

1. state는 UI 를 바꾸는데 필수적이다.
2. 리액트는 절대 반복(재평가)하지 않는다.
3. state 는 "모든 컴포넌트 함수를" "재평가 시킨다."
4. State 끌어올리기



[기본]================================================================================================================================

0. 시작은 npm start

1. src 안에, components 폴더를 만들어, component 를 만든다.

2. component 의 이름은, 첫글자는 대문자이여야한다.

3. 결국 붙여지는 곳은 메인 "App.js" 이다.

4. 해당 컴포넌트만 적용받는, 기본 스타일링은 .module.css이다.
    import "./ExpensiveItem..module.css";

5. 그냥 css 를 사용하면, "묶인 컴포넌트 전체가 바뀐다." 클래스네임을 확실히 지정할거면 이게 더 편하다
    import "./ExpensiveItem..css";

6. className 에서 _ 는 허용한다.

    <div className={styles.new_expense_controls}>  ==>  가능
    <div className={styles.new-expense-controls}>  ==>  불가능

7. class 는 className 이다.

8. props 넣는 것도 똑같다.

9. wrapper 로 감싸는 것(Layout or Card) 도 똑같다.
    단, Layout은 "index.js" 의
    
        root.render(
            <Layout>
            <App />
            </Layout>
        );

    안에 넣어줘야 겠다.
      
    "Nextjs 에서는 app.js 에서 넣었따."

10. 컴포넌트 함수를 "표현식인 화살표 함수로 만들 수도 있는 것도 같다".


<차이점>

1. 페이지의 유무

    nextjs 는 "각 페이지가 존재"하고, "컴포넌트를 묶어" ,최종적으로 "페이지에 집어넣는다."
        "페이지는 자동으로 app.js 에 바인딩되고". 렌더가 되면, 자동으로 index.html 을 만든다.

        <ExpensiveItem>, <ExpensiveDate> => <Expense> => App.js

    react 는 "여러 컴포넌트를 만들어서", "대단위의 컴포넌트 안에 묶고"," 대단위의 컴포넌트들을 App.js 에 묶으면", 
        App.js는 index.js 에 의해, index.html에 import 되고, 그것을 렌더한다.

        <ExpensiveItem>, <ExpensiveDate> => <Expense> => <pages>

    => "next의 각 페이지" == "react의 각 컴포넌트"



<설정>

1. but never use 에러 없애기

<이론>

1. state는 UI 를 바꾸는데 필수적이다.

    컴포넌트 함수는 결국 "함수"이다

    누군가는 "호출" 해야한다.

    하지만 우리는 "컴포넌트 함수"를 "호출한 적이 없다."
        * 어딘가에 Layout() 이런식으로 호출한 적이 있나? 아니 없다.

    대신에, html 코드처럼 사용했다.

    사실 이것은, 함수의 호출과 비슷한 기능을 한다.

    연관되어 있는 모든 JSX 코드들이 평가될때까지, 실행된다.

    후, "DOM 명령어로 번역"하여, "화면에 렌더"한다.

    시작은 "index.js", 컴포넌트 함수이다.

2. 리액트는 절대 반복(재평가)하지 않는다.

    함수는 한번 지나가면(평가되면) 실행이 되고, 끝이다. 반복문이 없지 않는 이상.

    리액트도 함수를 평가하여 작동한다. 리액트도 한번 지나가면 끝이다.

    "다시 재평가" 하려는 동작이 "state" 를 사용하는 것이다.

3. state 는 "모든 컴포넌트 함수를" "재평가 시킨다."

    생각해봐라, useEffect 사용하지 않으면 무한히 재평가되어 에러가 나는 state를

    그게 이유이다. 재평가되고, 깂이 바뀌면, 바뀌었으니 다시 재평가되고... 무한반복...

    하여튼 "state" 는 "모든 컴포넌트 함수를" "재평가 시킨다."

4. State 끌어올리기

    "자식으로부터" 받은 데이터를 "부모 컴포넌트" 로 "끌어 올릴 수 있다."
    "충분히 상위 컴포넌트로 끌어 올렸다면", 상위 컴포넌트 안에서, 새로운 값을 다른 silbling 에게 줄 수 있다.

        부모

            자식1

            자식2
                자식2-1
                자식2-2

        =>  [자식2-2] 가,   [자식2] 에게,
            [자식2]가,      [부모] 에게
            [부모]가,       [자식1]에게

5. 무상태 컴포넌트 = 프레젠테이셔널 컴포넌트 = dumb 컴포넌트
    : "단순한 출력"을 위해 사용되는 컴포넌트
        "상태가 저장되지 않는다."

        ** UI 를 조작하려면, "재평가 해야하고", "재평가하려면 STATE 가 필요함을 인지하자"

    "반대" : 상태 유지 컴포넌트, smart 컴포넌트

    
