[INDEX]================================================================================================================================

<스킬 및 기본>

0. 시작은 npm start
1. src 안에, components 폴더를 만들어, component 를 만든다.
2. component 의 이름은, 첫글자는 대문자이여야한다.
3. 결국 붙여지는 곳은 메인 "App.js" 이다.
4. 해당 컴포넌트만 적용받는, 기본 스타일링은 .module.css이다.
5. 그냥 css 를 사용하면, "묶인 컴포넌트 전체가 바뀐다." 클래스네임을 확실히 지정할거면 이게 더 편하다
6. className 에서 _ 는 허용한다.
7. class 는 className 이다.
8. props 넣는 것도 똑같다.
9. wrapper 로 감싸는 것(Layout or Card) 도 똑같다.
10. 컴포넌트 함수를 "표현식인 화살표 함수로 만들 수도 있는 것도 같다".
11. 컴포넌트 함수에서 style 관리하기
12. 컴포넌트 함수에서 동적 style 관리하기
13. [디버깅] Crome DevTool 에서, 소스, 파일 위치 들어가서, "중단점 설정" 후, "기능을 실행" 하여, 한줄한줄 읽어가며 디버깅 가능
14. [디버깅] Crome App 에서, "React Dev Tools" 를 다운받아, 사용해보기
15. localStorage 에 접근하기 (cookie 처럼), 접근하여 아주아주 간단한 로그인 구현
16. "리액트 포털"이란?
17. "리액트 포털"을 통해, 오버레이 컨텐츠를 표현하기(Modal 등 화면을 덮는 오버레이)
18. useEffct의 의존성은 여러개를 추가해도 된다.
19. useEffect의 의존성은, 상위항목으로부터 받아온 값도 가능하다
20. 디바운싱 (디바운스 = 그룹화)
21. useEffect의 클린업 프로세스
22. useEffect를 이용하여, 디바운싱을 만들기 with "클린업함수", Check Validation
23. useReducer HOOK 을 언제 사용하는가?
24. useReducer HOOK 사용해보기
25. Context 사용하기
26. store 의 Context 안에서, 모든 공급이 이루어지게 만들기 [가독성을 위해, 공급하는 value 를 "공급하는곳에서 적지 않기 위하여"] 
27. HooK 들의 유의사항
28. 커스텀 훅 만들기
29. 커스텀 훅 사용하기
30. 커스텀 훅과 매개변수
31. 현실적인 커스텀 훅 의 생성
32. 현실적인 커스텀 훅 의 사용
33. 커스텀 훅을 사용하여, 반복되는 INPUT FORM 을 처리해보자



[추가] useMemo와 useCallback 을 통한, 최적화

==== [HTTP 메서드] ===

 

<차이점>

1. 페이지의 유무
2. Router 의 유무
3. SSR 의 유무

<설정>

1. but never use 에러 없애기


<이론>

1. state는 UI 를 바꾸는데 필수적이다.
2. 리액트는 절대 반복(재평가)하지 않는다.
3. state 는 "모든 컴포넌트 함수를" "재평가 시킨다."
4. State 끌어올리기
5. 무상태 컴포넌트 = 프레젠테이셔널 컴포넌트 = dumb 컴포넌트
6. JSX 가 반드시, 하나의 root Element 로 묶여야 하는 이유
7. useRef 로 조작하는 것이 좋지 않은 이유 (읽는 것 제외하고)
8. 디바운싱 (디바운스 = 그룹화)
9. 리액트가 작동하는 방식에 대하여
10. App.js 처럼 상위 컴포넌트가 재평가되면, 모든 하위 자식들도 전부 재평가 및 실행 된다. "낭비를 어떻게 막을 수 없을까?"
11. 그럼 왜? 항상 사용하지 않는가?
12. 언제 React.memo() 를 사용하는가?
13. React.memo() 는 "원시값의 props" 를 비교하는 데에만 적합하다.
14. 그렇다면 함수형으로 props 를 넘긴다면, 어떻게, 재평가를 방지할 수 있을까?  React.memo() 에 넘기는 함수를 만들때 useCallback() 을 이용한다.
15. 그렇다면 "객체나 배열" 으로 props 를 넘긴다면, 어떻게, 재평가를 방지할 수 있을까?  React.memo() 에 넘기는 함수를 만들때 useMemo() 을 이용한다.
16. State 에 관하여
17. 커스텀 훅이란?




[기본]================================================================================================================================

0. 시작은 npm start

1. src 안에, components 폴더를 만들어, component 를 만든다.

2. component 의 이름은, 첫글자는 대문자이여야한다.

3. 결국 붙여지는 곳은 메인 "App.js" 이다.

4. 해당 컴포넌트만 적용받는, 기본 스타일링은 .module.css이다.
    import "./ExpensiveItem.module.css";

5. 그냥 css 를 사용하면, "묶인 컴포넌트 전체가 바뀐다." 클래스네임을 확실히 지정할거면 이게 더 편하다
    import "./ExpensiveItem..css";

6. className 에서 _ 는 허용한다.

    <div className={styles.new_expense_controls}>  ==>  가능
    <div className={styles.new-expense-controls}>  ==>  불가능

7. class 는 className 이다.

8. props 넣는 것도 똑같다.

9. wrapper 로 감싸는 것(Layout or Card) 도 똑같다.
    단, Layout은 "index.js" 의
    
        root.render(
            <Layout>
            <App />
            </Layout>
        );

    안에 넣어줘야 겠다.
      
    "Nextjs 에서는 app.js 에서 넣었따."

10. 컴포넌트 함수를 "표현식인 화살표 함수로 만들 수도 있는 것도 같다".

11. 컴포넌트 함수에서 style 관리하기
    
    <label style={{ color: "red", fontSize: "40px" , ...}}> Title </label>

12. 컴포넌트 함수에서 동적 style 관리하기

    <label style={{ color: 조건 ? "red" : "blue" }}> Title </label>

13. [디버깅] Crome DevTool 에서, 소스, 파일 위치 들어가서, "중단점 설정" 후, "기능을 실행" 하여, 한줄한줄 읽어가며 디버깅 가능

14. [디버깅] Crome App 에서, "React Dev Tools" 를 다운받아, 사용해보기

    : 사용하면, 개발자탭에서, 가장 우측에, component 와 profile 이 활성화된다.

        component 를 들어가면 오로지 React Component 만 보인다. => 모든 DOM 이 보이는 element 탭과 달리, 
        
        React와 관련된 것만 보여서 디버깅하기 쉽다.

            Hook, function, State 등...

15. localStorage 에 접근하기 (cookie 처럼), 접근하여 아주아주 간단한 로그인 구현

    : 일반적으로 "저장"은, "DB", "localStorage", "cookie"  가 대표적이다.
    
        DB 는 많이 해보았고,
        cookie 도, 인증을 위해 써보았다.

        "localStorage" 도 "cookie 처럼 클라이언트에 저장가능한 저장소"이며, 

        localStorage.메서드 로 접근한다.


        <코드> ==============================

            localStorage.setItem("name","vlaue") => 저장가능한
            localStorage.getItem("name")        => 값 가져오기
            localStorage.removeItem("name")     => 값 제거하기

                ...
        
        <총 코드>

                function Login() {
                    const [isLogin, setIsLogin] = useState(false);
                
                    function loginHandler(e) {
                        e.preventDefault();
        
-                       localStorage.setItem("Login", "1");
                        setIsLogin(true);
                    }
                
                    useEffect(() => {
-                       const storedUserLogin = localStorage.getItem("Login");
        
                        if (storedUserLogin === "1") {
                            setIsLogin(true);
                        } else {
                            setIsLogin(false);
                        }
                    }, []);
                
                    function logOutHandler(e) {
                        e.preventDefault();
                
-                       localStorage.removeItem("Login");
                        setIsLogin(false);
                    }
                
                    return (
                        <div>
                            <button onClick={loginHandler}> 로그인 </button>
                            <button onClick={logOutHandler}> 로그아웃</button>
                            {isLogin && <h1> 로그인되었습니다.</h1>}
                        </div>
                    );
                }
                export default Login;
                
16. "리액트 포털"이란?

    "Modal" 같은 "오버레이" 들은, 사실상,해당 HTML 과는 조금 다른 곳에서 실행되어어한다.

    전혀 다른 종류의 컴포넌트이면서, 화면을 분리시키기도 하고, "연관이 전혀 없음에도 한 컴포넌트 안에 같이 있을 수도 있다."

    마치 로그인 성공시 나오는 Modal 이, 로그인과는 전혀 관계 없는 컴포넌트 인 것 처럼
        (그렇지만 로그인 컴포넌트 한켠에 들어가있다.)

    이것을 방지하기위해, "리액트 포털"을 사용한다.

    "리액트 포털"은, "원하는 공간"에서, "원하는 JSX코드로 만든 컴포넌트"를 렌더하는것

        ** Modal 을 띄우면, "컴포넌트 함수의 한켠"이 아니고, body의 직계 자식이 되도록, 만들 수 있다.


17. "리액트 포털"을 통해, 오버레이 컨텐츠를 표현하기(Modal 등 화면을 덮는 오버레이)

    [포털을 사용하기에 필요한것] =>  "컴포넌트", "컴포넌트를 렌더할 장소"


    1) 기존의 Modal

        1. 모달을 만든다.
        2. 사용할 곳에서, modal 을 띄우거나, 제거하는 함수를 만든다.
        3. 모달 컴포넌트로 함수 포인터를 넘겨, 그곳에서도, 띄우거나, 제거할 수 있게 만든다. 

            < Modal 사용할 곳>

                import { useState } from "react";
                import Modal from "./components/UI/Modal";

                export default function App() {
                    const [modal, setModal] = useState(false);
                    
    -               function toggleModal() {
                        setModal((prev) => !prev);
                    }

                    return (
                        <div className="App">
                            <button onClick={toggleModal}> 모달 띄우기</button>
    -                       {modal && <Modal closeModal={toggleModal} />}

                            ...

            < Modal >

                import styles from "./Modal.module.css";

                function Modal(props) {
    -               const { closeModal } = props;

                    return (
                        <div className={styles.modal}>
    -                       <div className={styles.backDrop} onClick={closeModal}></div>
    -                       <div className={styles.modalContent} onClick={closeModal}>
                                <h1> 이것은 Modal</h1>
                                <h2> 모달이 띄워졌습니다. 아무곳이나 눌러 제거하세요</h2>
                            </div>
                        </div>
                    );
                }
                export default Modal;



    2) 포탈을 사용한 Modal

        1. 모달을 만든다.
        2. 모달을 만들때, 한 컴포넌트 함수에 전부 넣지 말고, "한 파일"에 "여러 컴포넌트 함수"를 만들어, "분리시킨다."
        3. index.html 파일에, "modal 용 root" 를 만든다. (id로 DOM 에 접근해 안착시키므로, id 를 잘 적어준다.)
        4. "react-dom"에 접근하여 하여, "createPortal()" 메서드를 import한다
        5. "createPortal()" 을 사용하여, "modal 용 root" 에서 "렌더되게 만든다".

        6. props 는 "실행하는곳" -> "Modal" -> "Modal 안의 여러 컴포넌트" 로 props drilling 한다.



        < index.html > ======================================================================

                ...
            <body>
                <noscript>You need to enable JavaScript to run this app.</noscript>
-               <div id="root-modal-backdrop"></div>
-               <div id="root-modal-content"></div>
                <div id="root"></div>
            </body>
            </html>

        < Modal 사용 할 곳> ======================================================================
        
            import { useState } from "react";
            import Modal from "./components/UI/Modal";

            export default function App() {
                const [modal, setModal] = useState(false);
                
-                   function toggleModal() {
                    setModal((prev) => !prev);
                }

                return (
                    <div className="App">
                        <button onClick={toggleModal}> 모달 띄우기</button>
-                       {modal && <Modal closeModal={toggleModal} />}

                        ...


        < Modal > ======================================================================

                import styles from "./Modal.module.css";
-               import { createPortal } from "react-dom";                                   // createPortal 을 import

-               function ModalBackDrop(props) {                                             // 각각의 파트를 분리 (선택사항)
                    const { closeModal } = props;
                    return <div className={styles.backDrop} onClick={closeModal}></div>;
                }

-               function ModalContent(props) {                                               // 각각의 파트를 분리 (선택사항)
                    const { closeModal } = props;
                    return (
                        <div className={styles.modalContent} onClick={closeModal}>
                            <h1> 이것은 Modal</h1>
                            <h2> 모달이 띄워졌습니다. 아무곳이나 눌러 제거하세요</h2>
                        </div>
                    );
                }

                function Modal(props) {
                    const { closeModal } = props;

                    return (
                        <div>
-                           {createPortal( <ModalBackDrop closeModal={closeModal} /> , document.getElementById("root-modal-backdrop") )}
-                           {createPortal( <ModalContent closeModal={closeModal} /> , document.getElementById("root-modal-content") )}
                        </div>
                    );
                }

                export default Modal;

            ==> [createPortal] 은, [첫번째 인자]로, 렌더될 "컴포넌트 함수(렌더 된 형태)"를 받고, [두번째 인자]로, "컴포넌트를 렌더할 장소" 를 받는다.

            ==> "App.js 에서, Modal 을 실행시키면", "Modal" 은 각 파트(혹은 뭉쳐진 하나의 파트)를 "portal 하여, index.html 의 root div 에서 실행시킨다".

            ==> "props"는 "App.js 에서 Modal 에만 전달"했으므로, "ModalContent" 와 "ModalBackDrop" 은 "Modal 에서 props 를 받아 사용"된다.



                
18. useEffct의 의존성은 여러개를 추가해도 된다.

    const [name,setName] = useState()
    const [password,setPassword] = useState()

    useEffect(()=>{
        ...
    },[ name, password ... 여러개 추가 가능])

19. useEffect의 의존성은, 상위항목으로부터 받아온 값도 가능하다

    props 로 "상위 컴포넌트에서, 바뀐것을 받았다면",
    그것또한, 종속성으로 추가 할 수 있다.

20. 디바운싱 (디바운스 = 그룹화)

    "디바운싱"이란, 계속해서 변경되는 state 가 있다고 생각해보자

        예를들면, "id를 입력중인 상황"

    유저는, 1초에 대략 5~10자 정도 되는 타자를 칠 것이다.

        변경되는 state는, 유저가 키를 누를때마다 변경되고, 이는 사실 불필요한 state 의 변경일것이다.

    그래서 "디바운싱"을 한다.

    유저가 타자를 다 치고 나서, "1초정도 쉰다면", 그때, "state" 를 기록하는 것이다.

    움직일때는 행동을 하지 않고, 움직임이 끝나면, 행동한다.

    움직임을 그룹화한다. 해서 "디바운싱이다."

21. useEffect의 클린업 프로세스

        useEffect 를 사용할때, "반환하는 함수"를 만들 수 있다.(화살표 함수도, 선언문 함수도 괜찮다.)

        이 함수를 "클린업 함수" 라고 부른다.

        [클린업 함수의 실행 타이밍]

            1. 클린업 함수는, useEffect 내부의 함수가 "실행되기 직전" 에 실행된다.
            2. "첫번째 useEffect 내부의 함수가 실행된 이후"부터 실행이 시작된다.

        [코드]
        
            const [name, setName] = useState()

            useEffect(()=>{

                ...

                return ()=>{
                    "클린업함수 실행문"
                    console.log("reset!")
                }

            },[name])

        [예시]
            
            "시작하고나면, useEffect 함수가 한번 실행"된다.
            "이후, 타이핑을 하게되면, name 이 변화"한다.
            "name 이 입력되기 직전에 클린업 함수가 실행"된다.

        [로그]

            name

            reset!
            name

            reset!
            name

            ...


22. useEffect를 이용하여, 디바운싱을 만들기 with "클린업함수", Check Validation

    [목적] : "중간에 타자를 치다가, 멈추면 그 이후에, Validation Check 를 하게 한다."
            : "타이핑 중간에는 Validation Check 를 하지 않는다."
            
    1) setTimeout 을 이용하여, 몇 초 후에, state에 기록되게 한다.

    2) useEffect에, 종속성을 추가하여, setTimeout 함수가, 조건부 실행되게 한다.

    3) 만약 중간에, "시간이 다되기전, 새로운 setTimeout이 시작되게 되면(다시 타이핑을 시작하면)",
        "클린업함수" 를 이용하여, "setTimeout 의 흘러가던 시간을 reset"한다.

        => 결국 "중간에 멈추지 않으면, setTimeout의 시간은 다시 reset 되고", 최종적으로 한번만 "setTimeout의 콜백함수가 실행되게 만드는 것"이다.

        import { useEffect, useState } from "react";

        function Practice() {
            const [name, setName] = useState("name");

            function nameChangeHandler(e) {
                setName(() => e.target.value);
            }

            useEffect(() => {
                const setTime = setTimeout(() => {
                    if (name == "ms") {
                        console.log("correct!");
                    } else {
                        console.log("wrong!");
                    }
                }, 2000);

                return () => {
                    clearTimeout(setTime);
                };
            }, [name]);

            return (
                <div>
                    <input
                        type={"text"}
                        value={name}
                        onChange={(e) => nameChangeHandler(e)}
                    />
                </div>
            );
            }

        export default Practice;



23. useReducer HOOK 을 언제 사용하는가?

    : 강력한 State 관련 도구로

        3개의 state 가 있을 때,

        "[ 1 ] 과 [ 2 ] 의 state를 사용"해, "[ 3 ]의 state 를 업데이트" 한다고 생각해보자.

        업데이트 과정에서, [1] 혹은 [2] 가 최신화가 되지 않아 있을 수도 있다.

        이때 우리는, "1과 2, 그리고 3을 한 항목으로 묶을 필요가 있다."

        방법은 두가지이다.

        1) 객체형태의 State 를 사용하여 한 State로 묶는다.
        2) "useReducer"를 사용한다.

            객체형태는, 간단하면 사용가능하다. 2,3가지 정도의 데이터는 묶을 만 하다
            "매우매우매우매우 복잡하고 많은 형태로 묶인 State 를 사용해야 할때" 그때, "useReducer"를 사용한다.


24. useReducer HOOK 사용해보기
        :이 Hook 함수를 사용하면 "컴포넌트의 상태 업데이트 로직"을 "컴포넌트에서 분리시킬 수 있다". 
            "상태 업데이트 로직(리듀서함수)"을 컴포넌트 바깥에 작성 할 수도 있고, 심지어 다른 파일에 작성 후 불러와서 사용 할 수도 있지요

    [기본]
    
        << 1. 리듀서함수의 정의 >>

            function reducerFn(state, action){          => 리듀서함수는, "현재상태"와 "액션"을 파라미터로 받아와서 "새로운 상태를 반환해주는 함수"
                retrun nextState                        => 리듀서 함수의 반환값은 곧, "새로운 상태"
            }

                * state : 현재 상태
                * action : "type" 값이 존재하고, "나머지는 맘대로 무엇이든 넣을 수 있는", "객체형태"의 코드
                    type 은 보통, "대문자", "_" 를 사용한다.


                <리듀서 함수 예시> ============================================================

                    => "취할 모든 액션을 정의한다."

                    function reducer(state, action) {           // 무엇이든, "action.type"을 확인하여, "원하는 action"을 취하게한다.
                        if (action.type == "INCREMENT") {      
                            return state + 1;                    // 반환에는, "state" 를 변화시킨다.
                        }    
                        if(action.type == "DECREMENT")  {
                            return state - 1;
                        }   
                    }

        << 2. 컴포넌트 함수 내에서, 정의한 "리듀서함수"를 가져와서 사용하기 >>

                function Counter(){
                    const  [number, dispatch] = useReducer(reducerFn, 0);

                    function OnIncrease(){
                        dispatch({type: 'INCREMENT' })
                    }

                    function OnDecrease(){
                        dispatch({type: 'DECREMENT' })
                    }

                    retrun (
                        <div>
                            <button onClick={OnIncrease}> +1 </button>
                            <button onClick={OnDecrease}> -1 </button>
                        </div>
                    )
                }

        << 3. 결합 >>

                import React, { useReducer } from 'react';

                function reducer(state, action) {
                    switch (action.type) {
                        case 'INCREMENT':
                            return state + 1;
                        case 'DECREMENT':
                            return state - 1;
                        default:
                            return state;
                    }
                }

                function Counter() {
                    const [number, dispatch] = useReducer(reducer, 0);

                    const onIncrease = () => {
                        dispatch({ type: 'INCREMENT' });
                    };

                    const onDecrease = () => {
                        dispatch({ type: 'DECREMENT' });
                    };

                    return (
                        <div>
                            <h1>{number}</h1>
                            <button onClick={onIncrease}>+1</button>
                            <button onClick={onDecrease}>-1</button>
                        </div>
                    );
                }

                export default Counter;


        [결론]
            : useReducer는 리듀서함수, 초기값, 초기함수 를 파라미터로 갖는다

                리듀서함수는, state와, action 을 파라미터로 갖는다.

                리듀서함수는, "반환값으로" , "변할 State 를 갖는다"            [ useState 의 setValue() 처럼]

                리듀서함수는, "실행 될 action"을 "전부 적고", "type" 에 따라, "다른 action을 취하도록 한다". 

                리듀서함수의 action(실행함수) 를 사용하기 위해, "dispatch" 명령어로, "action 안에 정의한 객체 프로퍼티 type 을 가져온다."   [type == id(불러올때 쓸 이름)]

                "dispatch"로 "특정 type을 정하여", [리듀서 함수의 action(실행함수)를 불러오는 것]이다.

                "action 이 실행"되면, "type(action)마다 정해진, 다른 return 값" 이, "새로운 상태"가 된다.

            
        [추가]  - state는 "객체"를 보통 갖는다

-           : state는 "객체"를 보통 갖는다.

                function reducerFn(state, action){
                    if(action.type == "GET_INFO"){
                        retrun { name : "ms", age : 35 }        // "객체값을 갖을 수 다."
                    }
                    if(action.type == "DELETE_INFO")
                        retrun { name : null, age : null }
                }

                function GetUserInfo(){
                    const [userInfo, dispatch] = useReducer(reducerFn, {name : "", age : null});
                }
                
-       [추가] - useEffct의 종속성으로 활용할 때

                function GetUserInfo() {
                    const [userInfo, dispatch] = useReducer(userInfoReducer, {
                        name: "",
                        age: null,
                    });
                    
                        일때,
                    
                    useEffect(()=>{
                        ...
                    },[ userInfo ]) 	// 이렇게 사용하지 않는다.
                    
                    
                    <개선> 
                    
                    useEffect(()=>{
                        ...
                    },[ userInfo.name ]) 	// 프로퍼티를 뽑아 사용한다.
                

25. Context 사용하기
    
    : 앱 전반에 걸쳐, 같은 데이터를 공유하는 코드

    "1) createContext"
        :   createContext는, context 를 만들어주는 react의 빌트인 메서드이다.

        [const myContext = createContext(defaultValue)]
                    
            * defaultValue는, "자동완성" 을 위해 사용한다고 해도 무방하다.
                Provider 를 통해, "아무값도 넘기지 않으면", defaultValue 가 사용된다.

    "2) context.Provider"

        : Conetext.Provider 는, "context 를 구독하는 컴포넌트"들에게, "context 의 변화를 알린다".

        [myContext.Provider value={값}]


    <기본적인 사용>

        1) "context" 를 만든다.
        2) "context를 공급할 곳" 에서, "만든 context를 import" 한다.
        3) App.js 처럼, "전방위적으로 앱을 감싸는 컴포넌트"를 "context 로 감싼다."
        4) 단 감쌀때는, "context 변화를 알리는, context.Provider" 로 "감싸야"한다.  [공급한다.]

        
            <context>
                import { createContext } from "react";

    -           const AuthContext = createContext({
                    isLoggedIn: false,
                });

    -           export default AuthContext;

            <App.js>

    -           import AuthContext from "../store/..."

                    ...

                    <div className="App">
    -                   <AuthContext.Provider value={ {isLoggedIn: false} }>
                            <Login />
                            <NewExpenseon SaveChildData={saveExpenseDataHandler} />
                            <Expense fromNewExpense={expensData} yearValue={year} />
    -                   </AuthContext.Provider>
                    </div>


            ** "기본 값 (defaultValue) 는 공급자가 없을때나, 유용한 것"이다. "Provider 가 전달하는 value 와는 전혀 관계 없다". 다만, "자동완성기능"을 위해 필요하다
            ** Provder 는 value 를 하위 항목들에게 "공급"한다. "공급된 value" 는, "하위항목들도 접근하여 사용이 가능"하다.
            ** 지금은  <AuthContext.Provider value={ {isLoggedIn: false} }> 처럼 고정된 value 를 공급하지만, 
                App.js 에서 "State" 를 사용해, "동적으로 공급" 할 수도 있다.

    < useContext 를 이용한 "구독" >

        1) useContext 를 import 한다.
        2) store 에 담겨있는 context 객체를 import 한다.
        3) "useContext" 를 이용하여, "context를 구독"한다
        4) context 를 사용한다.

            < Login Component >

-               import useContext from "react"
-               import AuthContext from "../store/.."

                function Login(){
-                   const ctx = useContext(AuthContext)

                    retrun(
                        <div>
-                           {ctx.isLoggedIn}
                        </div>
                    )
                }

    [반드시 알고있어야 할 것]**

        ** 컨텍스트를 Provide 하는 "Provider는", "context 에 있는 isLoggedIn 을 전달 하는 것이 아니다."
            스스로 적은 "value" 객체를 전달하는 것이다.

           "이 말인 즉, 굳이 store 폴더에서, defaultValue 를 적지 않아도, "
                Provider의 value 를 통해, "아무 값(혹은 함수)이나 더 전달 할 수 있다는 것"이다.

                    [context 에서 정의하지 않아서, 자동완성은 안되겠지만]

            ** 이는 보통, "context의 상태(데이터)를 변화하는 함수들을 더 전달" 할것이다. 
                

            <App.js>

    -           import AuthContext from "../store/..."
                    const [isLogin, setIsLogin] = useState(false)

                    ...
                    function changeState (...){
                        setIsLogin(...)
                    }

                    <div className="App">
    -                   <AuthContext.Provider value={ {isLoggedIn: isLogin, onClick={changeState}} }>  
                            <Login />
                            <NewExpenseon SaveChildData={saveExpenseDataHandler} />
                            <Expense fromNewExpense={expensData} yearValue={year} />
    -                   </AuthContext.Provider>
                    </div>

            ** 사용하는 곳에서 "useContext" 를 사용하여, "함수를 받아 사용"한다면, "App.js" 에서 정의된 함수이므로, 
                App.js 의 "isLogin State" 가 변하고, 이는 "공급할 isLoggedIn 의 value 가 바뀔것"이고
                "이는 구독하여 사용하는 모든 곳에 있는  value 가 바뀔것"이다.


26. store 의 Context 안에서, 모든 공급이 이루어지게 만들기 [가독성을 위해, 공급하는 value 를 "공급하는곳에서 적지 않기 위하여"] 

    < 기본사용 메커니즘 >
        
        1. store에 context를 만들어, App.js 에 .Proivder 를 이용해, 하위 컴포넌트들을 감싸, value 를 넘긴다.

        2. value 는, App.js 의 .Proivder 안에서 정의되며, App.js의 함수와 State를 모든 앱에 걸쳐 공급한다.

        3. App.js 에서 정의된 함수와 State 를 넘겨받은 하위 컴포넌트들은, useState 를 사용하여, vlaue 에 접근해, value 를 사용한다.

        ==> value 에 넣어 공급할, State와, 함수들을 App.js 에서 정의하기에, 복잡해진다.

    < App.js(공급할곳) 에서 State와, 함수들을 정의하지 않고, Store의 Context에서 모든 것을 처리해보자>


        <store/AuthContext.js> ================================================================================

            import { createContext, useState } from "react";

            const AuthContext = createContext({
                isLoggedIn: false,
                loginHandler: ()=>{},
                logoutHandler:()=>{}
            });

            export function AuthContextProvider(props) {
                const [isLoggedIn, setIsLoggedIn] = useState(false);

                function loginHandler() {
                    setIsLoggedIn(true);
                }
                function logoutHandler() {
                    setIsLoggedIn(false);
                }

                const context = {
                    isLoggedIn: isLoggedIn,
                    loginHandler: loginHandler,
                    logoutHandler: logoutHandler,
                };

                return (
                    <AuthContext.Provider value={context}>
                        {props.children}
                    </AuthContext.Provider>
                );
            }

            export default AuthContext;

        ========================================================================================================================

        ==> App.js 에서 할 것을, Store의 Context 로 옮겨왔다.

            1) AuthContext 를 Provide 하기위한 함수를 재정의 [AuthContextProvider]

            2) 재정의한 AuthContextProvider 를 export 하고, 반환값으로, AuthContext.Proivder 에, props.children 으로,
                모든 하위 컴포넌트에서 사용 가능하게 한다.

            3) value = { {name: ..., login: ...} } 처럼 각각의 객체를 정의하지 말고,
                context 라는 변수를 만들어, value 안에 넣어준다.

                    => 실질적으로 공급되는 값들은  context 인것이다.
                
            4) context 안에는, "State" 와  "함수(State를 조작할)" 가 들어간다.

            5) createContext 로 만든 AuthContext 안에는 defaultValue 가 들어간다.

                    => defaultValue 는 단지, "자동완성"을 위한 값일 뿐이다. 어차피 Proivder를 사용한다면,
                         defaultValue의 데이터는 필요없다.


        < App.js > ================================================================================

                : 기존에" AuthContext를 이용해, .Proivder 메서드로, 공급했다".
                    하지만 그 일은, 이제, "AuthContextProvider" 가 대신할것이다.

                    또한, App.js 에서 Provider 을 사용할 필요가 없어졌다.

            ==>  전부 모이는 "index.js" 에 가서, "AuthContextProvider" 로 감싸준다.

        < index.js > ================================================================================

            import { AuthContextProvider } from "./store/auth-context";

            const root = ReactDOM.createRoot(document.getElementById("root"));
            root.render(
                <AuthContextProvider>
                    <Layout>
                    <App />
                    </Layout>
                </AuthContextProvider>
            );

        < 사용할 곳 > ================================================================================

                : 이제 사용할 곳에서 똑같이, "createContext로 만든, AuthContext 를 import" 하고, 
                    "useContext" 를 이용하여, "Provider 내부에 있는 값을 사용"하면된다.

            import { useContext, useState } from "react";
            import AuthContext from "../../store/auth-context";

            function UseContextPractice() {
                const ctx = useContext(AuthContext);

                function login() {
                    ctx.loginHandler();                                     // true
                }
                function logout() {
                    ctx.logoutHandler();
                }
                console.log(ctx.isLoggedIn);                                // false

                return (
                    <div>
                    <button onClick={login}> 컨텍스트 로그인 </button>
                    <button onClick={logout}> 컨텍스트 로그아웃</button>
                    </div>
                );
            }

            export default UseContextPractice;

        
        < 주의사항 >
            
            반드시 "매우매우 긴 props chain" 과 "전반적인 앱을 컨트롤하는 State"를 이용할때 (Auth, 전체 Banner 등..) 만 사용한다.

            "자주 바뀌는 State" 에 관해서는 "Context" 를 사용하지 않는다! - 리액트 개발자의 공식문서

            그래서 "Redux" 를 사용할것이다.

                            

27. HooK 들의 유의사항

    1. HOOK 은 반드시 "리액트 컴포넌트"안에서 사용해야한다. 
        리액트 컴포넌트 밖에 정의한 "리듀서 함수", "next의 SSR", "API" 등.. 다른곳은 안된다.

    2. HOOK 은 반드시, "컴포넌트 함수의 최상위에 사용해야한다"
        콜백 함수, 중첩 함수 같은, 하위 블록의 함수에서 사용이 불가능하다.

    3. 하나의 의존성이라도 있는 경우, "웬만하면 useEffect를 사용"한다. 또한, 의존성에 그 값을 넣는다.
            

28. 커스텀 훅 만들기

    <규칙> ***
        "반드시!!" 리팩토링 하는 함수의 이름을 "use" 로 시작하게 만든다.

            function use... ( O ) 
            function useCounter ( O ) 
            function useAdd ( O ) 

            function refactoringHook ( X )

        "그래야만, 리액트가 확인하고, 커스텀훅으로 인정된다."

    <추가사항>
        
        폴더와 파일이름은 마음대로 정해도된다. 다만, 분명히 커스텀 훅임을 알아볼 수 있게 짓도록 하자

        "hooks" 폴더의 "use-Counter.js" 처럼

    <예시>

        <컴포넌트 1>
            import {useState, useEffect} from "react"
            
            function ...(){
                const [counter, setCounter] = useState(0)

                useEffct(()=>{
                    const interval = setInterval(()=>{
                        setCounter((prev)=>(prev +1))       // 차이점 : +1 이됌
                    }, 1000)

                    retrun ()=> clearInterval(interval)
                },[])

                return (
                    <div> {counter} </div>
                )
            }

        <컴포넌트 2>
            import {useState, useEffect} from "react"
            
            function ...(){
                const [counter, setCounter] = useState(0)

                useEffct(()=>{
                    const interval = setInterval(()=>{
                        setCounter((prev)=>(prev -1))       // 차이점 : -1 이됌
                    }, 1000)

                    retrun ()=> clearInterval(interval)
                },[])

                return (
                    <div> {counter} </div>
                )
            }

                                ==>>

        <커스텀훅>

            "/hooks/use-counter.js"

                function useCounter(){                          // 반드시 use 로 시작할것
                    const [counter, setCounter] = useState(0)   // 훅 사용을 그대로 복사

                    useEffct(()=>{
                        const interval = setInterval(()=>{
                            setCounter((prev)=>(prev -1))       
                        }, 1000)

                        retrun ()=> clearInterval(interval)
                    },[])

                    return counter;                             // "상태"를 반환 ***
                        
                }   

                export default useCounter                       // export 한다.


            
29. 커스텀 훅 사용하기

    : 기존 컴포넌트에, 리팩토링 한 "커스텀 훅을 가져와 사용한다."

        <컴포넌트 1>

            import useCounter from "../../..."

            function ...(){
                const counter = useCounter()

                return (
                    <div> {counter} </div>
                )
            }

    ==> 이때, 리팩토링해 가져온 "상태" 는 "공유되는 것이 아니라", "각각 사용한 컴포넌트 함수 안에서 따로 적용된다."


30. 커스텀 훅과 매개변수

    : 당연히, 커스텀훅 에도 "매개변수" 를 사용할 수 있다.

        기존 컴포넌트2 에서는 컴포넌트1 의 함수와 달리 + 대신 - 를 사용한다.

        이를 위해, "새 커스텀 훅" 을 만들기 보다는, "기존의 커스텀훅에, 매개변수를 통해, 다른 역할을 하게 만들자."

    현 커스텀 훅에 필요한 매개변수는
            "초기상태", "함수 로직", "useEffect의 의존성" 이다.

        <커스텀훅>
            "/hooks/use-counter.js"

                function useCounter(initValue, customFunction){             
                    const [counter, setCounter] = useState(initValue)   // 매개변수        

                    useEffct(()=>{
                        const interval = setInterval(()=>{
                            customFunction                      // 매개변수
                        }, 1000)

                        retrun ()=> clearInterval(interval)
                    },[])

                    return counter;
                        
                }   

                export default useCounter 


        <혹은 다른방법>

                function useCounter( forward = true ){           // 매개변수 설정 후 초기값 부여
                    const [counter, setCounter] = useState(0)          

                    useEffct(()=>{
                        if(forward){
                            const interval = setInterval(()=>{
                                setCounter((prev)=>(prev +1))       // 매개변수 에 따라 바뀌는 함수
                            }, 1000)
                        } else{
                            const interval = setInterval(()=>{
                                setCounter((prev)=>(prev -1))       // 매개변수 에 따라 바뀌는 함수
                            }, 1000)
                        }

                        retrun ()=> clearInterval(interval)
                    },[counter])

                    return counter;
                        
                }   

                export default useCounter 

31. 현실적인 커스텀 훅 의 생성

    예시) HTTP 요청

        <App.js>
            import React, { useEffect, useState } from 'react';

            import Tasks from './components/Tasks/Tasks';
            import NewTask from './components/NewTask/NewTask';

            function App() {
                const [isLoading, setIsLoading] = useState(false);
                const [error, setError] = useState(null);
                const [tasks, setTasks] = useState([]);                         // 차이점 1 : State 사용

                const fetchTasks = async (taskText) => {
                    setIsLoading(true);
                    setError(null);
                    try {
                        const response = await fetch(
                            'https://react-http-6b4a6.firebaseio.com/tasks.json'     // 차이점 2 : http 요청 방법(get)
                        );

                        if (!response.ok) {
                            throw new Error('Request failed!');
                        }

                        const data = await response.json();

                        const loadedTasks = [];

                        for (const taskKey in data) {
                            loadedTasks.push({ id: taskKey, text: data[taskKey].text });
                        }

                        setTasks(loadedTasks);                                      // 차이점3. State 사용 유무, 결과값 사용 방법
                    } catch (err) {
                        setError(err.message || 'Something went wrong!');
                    }
                    setIsLoading(false);
                };
                        ...

        <컴포넌트A>

            import { useState } from 'react';

            import Section from '../UI/Section';
            import TaskForm from './TaskForm';

            const NewTask = (props) => {
                const [isLoading, setIsLoading] = useState(false);          // 차이점 1 : State 하나 부족
                const [error, setError] = useState(null);

                const enterTaskHandler = async (taskText) => {
                    setIsLoading(true);
                    setError(null);
                    try {
                        const response = await fetch(
                            'https://react-http-6b4a6.firebaseio.com/tasks.json',    // 차이점 2 : http 요청 방법(post)
                            {
                            method: 'POST',
                            body: JSON.stringify({ text: taskText }),
                            headers: {
                                'Content-Type': 'application/json',
                            },
                            }
                        );

                        if (!response.ok) {
                            throw new Error('Request failed!');
                        }

                        const data = await response.json();

                        const generatedId = data.name;                              // 차이점3. State 사용 유무, 결과값 사용 방법
                        const createdTask = { id: generatedId, text: taskText };

                        props.onAddTask(createdTask);
                    } catch (err) {
                        setError(err.message || 'Something went wrong!');
                    }
                    setIsLoading(false);
                };

                    ...

        ==> 이 비슷한 두 함수를, "커스텀훅" 으로 만들기 위해서는

            1. 한쪽에선 사용하지 않는 State 는 공용이므로 삭제,
            2. fetch 의 URL 은 동적으로 여기저기 사용해야하므로, [ FETCH.URL ]
            3. fetch 의 방법은, 서로 다르므로, [ FETCH.METHOD]
            4. feth 의 결과값 사용 방식이 서로 다르므로 [ fetch의 결과값만 따로 저장 ]

  
        => 최종적으로 이것들을 아우르는, "재사용가능한 커스텀훅" 을 만들어보자면,

    
        <커스텀 훅>

        function useHttp(fecthConfig,applyData) {                                 // 이름에는, 반드시 "use"
                                                                        // fecthConfig 에는, url, method, headers, body 가 필요할 것이다.
            const [isLoading, setIsLoading] = useState(false);
            const [error, setError] = useState(null);                   // "task" 를 담은 "State" 는 삭제
          
            async function sendRequest() {                              // 공용으로 쓰기위한 함수이름 변경
              
              setIsLoading(true);
              setError(null);
              try {
                const response = await fetch(fecthConfig.url, {
                  method: fecthConfig.method ? fecthConfig.method : "GET", 
                  body: fecthConfig.body !== null ? JSON.stringify(fecthConfig.body) : null,
                  headers: fecthConfig.headers !== null ? fecthConfig.headers : null,
                });
          
          
                if (!response.ok) {
                  throw new Error("Request failed!");
                }
          
                const responseData = await response.json();         // data 까지만 뽑고, 추후처리는 각 컴포넌트마다 다르게 해야하므로 이하 삭제

                applyData(responseData)                             // "추후의 데이터 처리" 를 위해, "외부함수"(useHttp)에서 "참조를 위해", applyData 함수에 넣어 넘긴다.

              } catch (err) {
                setError(err.message || "Something went wrong!");
              }
              setIsLoading(false);
            }
          
            return {                                // useHttp 훅을 사용하면, 결과적으로 반환되는 "State" 와, "값"
              isLoading,       
              error,
              sendRequest,                          // isLoading:isLoading, error:error ... 을 모던 자바스크립트는 줄여서 쓸 수 있다.
            };
          }
          
          export default useHttp;

    ==> const useHttpResult = useHttp() 처럼, 사용하면, 
            useHttpResult = {isLoading, error, sendRequest} 의 결과값이 나올 것이다.

            "isLoading" 과 "error" 는 "커스텀 훅" 에서 반환된 "상태" 가 있을 것이고
            "sendRequest 함수"에서는, "responseData" 가 "applyData 함수 파라미터"에 의해, 부모(사용한곳) 으로 전달될 것이다. [클로저]
                : sendRequest 를 호출하면, responseData 를 파라미터로, fetch 한 값을 사용할 수 있다

32. 현실적인 커스텀 훅 의 사용

        import useHttp from "./hooks/use-http";

        function App() {
        const [tasks, setTasks] = useState([]);
        const fecthConfig = {
            url: "https://react-demo-771dc-default-rtdb.firebaseio.com/demo.json",  // 필요하다면, body와, headers 까지 포함
        };

        function applyData(data) {      // data 안에는, useHttp 에서 받아온, responseData 가 들어갈 것이다.
            const loadedTasks = [];

            for (const taskKey in data) {
                loadedTasks.push({ id: taskKey, text: data[taskKey].text });
            }

            setTasks(loadedTasks);
        }

        const useHttpResult = useHttp(fecthConfig, applyData);

        const { isLoading, error, sendRequest } = useHttpResult;    

        useEffect(() => {   // useHttpResult 의 결과인 sendRequest 함수를 호출하면,
            sendRequest();  // useHttp 안의 sendRequest 함수가 실행되고, fetch함수 내부의 sendRequest() 함수가 실행될것이다.
        }, []);             // 그 안에는 responseData 가 담겨있고, App.js 에서 사용한, applyData 함수에 의해, State 로 들어갈것이다.

        function taskAddHandler(task) {
            setTasks((prevTasks) => prevTasks.concat(task));
        }

    1. useHttp 커스텀훅 

        : 나를 import 하면, 결과로 내 안의 isLoading, error State 와, sendRequest() 함수를 보내줄게

    2. App.js

        : 알았어, 너를 사용해서, useHttpResult 로, isLoading, error, sendRequest 를 받았어

        : [sendRequest 의 fetch 결과]인 "responseData" 로[ sendRequest 내부의 함수]인, "applyData(responseData)" 가 자동으로 실행되는데,
            applyData 는 내 것을 사용할거야

        : applyData( 파라미터 ) 안의 파라미터에는, 너가 준 responseData 가 들어있어, 그것을 가지고 나는 조작해서, tasks State 안에 넣고 사용할게


    ==> [props 의 상위 컴포넌트로의 전달 과 같은 것]

        상위 컴포넌트에서, 하위 컴포넌트로, props 로 함수를 주면,

        하위 컴포넌트에서 실행하면, 실제로는 상위 컴포넌트에서 실행되는 것과 같고,
            그 파라미터 안의 값은, 하위컴포넌트의 값을 가져온다.


33. 커스텀 훅을 사용하여, 반복되는 INPUT FORM 을 처리해보자

        import styles from "./basic-form.module.css";
        import AlertFun from "./alert";
        import { useEffect, useState } from "react";

        function BasicForm() {
            const [inputText, setInputText] = useState("");
            const [inputEmail, setInputEmail] = useState("");       // 만약 input 이 수백개라면? 수백개를 다 쓰나?

            const [textIsTouched, setTextIsTouched] = useState(false);
            const [emailIsTouched, setEmailIsTouched] = useState(false);

            const [error, setError] = useState(false);

            function validationCheck() {
                if (textIsTouched && emailIsTouched) {
                    if (
                        inputText.trim() === "" ||
                        inputEmail.trim() === "" ||
                        !inputEmail.includes("@")
                    ) {
                        setError(true);
                    }
                }
            }

            useEffect(() => {
                validationCheck();
            }, [inputText, inputEmail]);

            function inputNameHandler(e) {                      // 만약 input 이 수백개라면? 수백개를 다 쓰나?
                setInputText(e.target.value);
            }

            function inputEmailHandler(e) {
                setInputEmail(e.target.value);
            }
            return (
                <form className={styles.maindiv}>
                    <label htmlFor="text"> 이름</label>
                        ...
                </form>
            );
        }

        export default BasicForm;

    <리팩토링>=======================================================================================

        import styles from "./basic-form-refac.module.css";
        import AlertFun from "./alert";
        import { useEffect, useState } from "react";
        import useInput from "../hooks/use-input";

        function BasicFormRefac() {

            const [error, setError] = useState(false);

            const inputTextResult = useInput((inputText) => String(inputText).trim() === "");
            const inputEmailResult = useInput((inputEmail) => !String(inputEmail).includes("@"));

            const {
                inputValue: inputText,
                hasError: inputTextError,
                inputIsTouched: inputTextIsTouched,
                inputHandler: inputTextHandler,
                inputTouchHandler: inputTextTouchHandler,
            } = inputTextResult;

            const {
                inputValue: inputEmail,
                hasError: inputEmailError,
                inputIsTouched: inputEmailIsTouched,
                inputHandler: inputEmailHandler,
                inputTouchHandler: inputEmailTouchHandler,
            } = inputEmailResult;

            function validationCheck() {
                if (inputTextIsTouched && inputEmailIsTouched) {
                    if (inputTextError || inputEmailError) {
                        setError(true);
                    }
                }
            }

            useEffect(() => {
                validationCheck();
            }, [inputText, inputEmail, inputTextIsTouched, inputEmailIsTouched]);

            return (
                <form className={styles.maindiv}>
                    <label htmlFor="text"> 이름</label>
                    <input
                        type={"text"}
                        id={"text"}
                        onChange={inputTextHandler}
                        onBlur={inputTextTouchHandler}
                    />
                    <label htmlFor="email"> 이메일</label>
                    <input
                        type={"email"}
                        id={"email"}
                        onChange={inputEmailHandler}
                        onBlur={inputEmailTouchHandler}
                    />
                    {error && <AlertFun />}
                </form>
            );
        }

        export default BasicFormRefac;

    <커스텀훅> =================================================================

    [리팩토링 해야 하는 것들]
        1. useState
        2. validation
        3. validation 하기 위한, inputHandelr 함수  => 아웃소싱해서 호출할것
        4. validation 하기 위한, isTouchedHandler 함수  => 아웃소싱해서 호출할것

    [return 해야 하는 상태 (부모측에서 사용할 값)]
        1. 입력되는 값의 상태
        2. 인풋의 validation 결과
        3. 이벤트 리스너에 함수로 들어갈 함수들 (inputHandelr, isTouchedHandler )  => 아웃소싱해서 호출하므로

    [부모로부터 받아야 하는 값들]
        1. validation 로직

        ==============================

        import { useState } from "react";

        function useInput(inValidationCheck) {
            const [inputValue, setInputValue] = useState(); // 입력되는 값의 상태
            const [inputIsTouched, setInputIsTouched] = useState(false); // touched 되어있는지의 상태

            const inputIsInvalid = inValidationCheck(inputValue); // inputValue 를 체크해보니, invalid 한 상태냐? ***
            const hasError = inputIsTouched && inputIsInvalid; // 터치 햇는데, invalid 한 상태냐? => 에러발생

            function inputHandler(e) {          // 입력값 받기위한 함수       ==>  이 커스텀훅을 사용하는곳에서, 호출가능하다.
                setInputValue(e.target.value);
            }

            
            function inputTouchHandler() {      // 터치되었는지 확인하는 함수     ==>  이 커스텀훅을 사용하는곳에서, 호출가능하다.
                setInputIsTouched(true);
            }

            return {
                inputValue,
                inputIsTouched,
                hasError,
                inputHandler,
                inputTouchHandler,
            };
        }
        export default useInput;

        // inputValue 를 체크해보니, invalid 한 상태냐? ***
        //  : 반드시, 이 커스텀 훅 안에 있는 value 를 사용해야한다.
        //  : 그래야 이 커스텀 훅을 여러번 사용했을때, 서로 다른 "완전히 다른 value 들을 넣을 수 있으므로"
        //  : 실제 실행장소는, 부모이므로, [이 함수 내부의 값을 사용하기 위해 함수형으로 넣는다.]


    => 더 복잡해진건 기분탓인가..!

         

    
        

            
<차이점>

1. 페이지의 유무

    nextjs 는 "각 페이지가 존재"하고, "컴포넌트를 묶어" ,최종적으로 "페이지에 집어넣는다."
        "페이지는 자동으로 app.js 에 바인딩되고". 렌더가 되면, 자동으로 index.html 을 만든다.

        <ExpensiveItem>, <ExpensiveDate> => <Expense> => App.js

    react 는 "여러 컴포넌트를 만들어서", "대단위의 컴포넌트 안에 묶고"," 대단위의 컴포넌트들을 App.js 에 묶으면", 
        App.js는 index.js 에 의해, index.html에 import 되고, 그것을 렌더한다.

        <ExpensiveItem>, <ExpensiveDate> => <Expense> => <pages>

    => "next의 각 페이지" == "react의 각 컴포넌트"



<설정>

1. but never use 에러 없애기

<이론>

1. state는 UI 를 바꾸는데 필수적이다.

    컴포넌트 함수는 결국 "함수"이다

    누군가는 "호출" 해야한다.

    하지만 우리는 "컴포넌트 함수"를 "호출한 적이 없다."
        * 어딘가에 Layout() 이런식으로 호출한 적이 있나? 아니 없다.

    대신에, html 코드처럼 사용했다.

    사실 이것은, 함수의 호출과 비슷한 기능을 한다.

    연관되어 있는 모든 JSX 코드들이 평가될때까지, 실행된다.

    후, "DOM 명령어로 번역"하여, "화면에 렌더"한다.

    시작은 "index.js", 컴포넌트 함수이다.

2. 리액트는 절대 반복(재평가)하지 않는다.

    함수는 한번 지나가면(평가되면) 실행이 되고, 끝이다. 반복문이 없지 않는 이상.

    리액트도 함수를 평가하여 작동한다. 리액트도 한번 지나가면 끝이다.

    "다시 재평가" 하려는 동작이 "state" 를 사용하는 것이다.

3. state 는 "모든 컴포넌트 함수를" "재평가 시킨다."

    생각해봐라, useEffect 사용하지 않으면 무한히 재평가되어 에러가 나는 state를

    그게 이유이다. 재평가되고, 깂이 바뀌면, 바뀌었으니 다시 재평가되고... 무한반복...

    하여튼 "state" 는 "모든 컴포넌트 함수를" "재평가 시킨다."

4. State 끌어올리기

    "자식으로부터" 받은 데이터를 "부모 컴포넌트" 로 "끌어 올릴 수 있다."
    "충분히 상위 컴포넌트로 끌어 올렸다면", 상위 컴포넌트 안에서, 새로운 값을 다른 silbling 에게 줄 수 있다.

        부모

            자식1

            자식2
                자식2-1
                자식2-2

        =>  [자식2-2] 가,   [자식2] 에게,
            [자식2]가,      [부모] 에게
            [부모]가,       [자식1]에게

5. 무상태 컴포넌트 = 프레젠테이셔널 컴포넌트 = dumb 컴포넌트
    : "단순한 출력"을 위해 사용되는 컴포넌트
        "상태가 저장되지 않는다."

        ** UI 를 조작하려면, "재평가 해야하고", "재평가하려면 STATE 가 필요함을 인지하자"

    "반대" : 상태 유지 컴포넌트, smart 컴포넌트

6. JSX 가 반드시, 하나의 root Element 로 묶여야 하는 이유

    JSX 는 React.createElement 로 반환된다.
    그곳에서 하나의 값만 반환되기 때문에, 그렇다.

7. useRef 로 조작하는 것이 좋지 않은 이유 (읽는 것 제외하고)

        const nameRef = useRef()

        const nameData = nameRef.current.value      // 읽기
        nameRef.current.value = ""                  // 쓰기

        <input type="text" ref=nameRef>             // 연결

    : useRef 는 DOM 을 직접 읽는다.
        이는 "React"에 의해 "DOM 이 조작되는 것이 아니라", "실제 DOM 이 조작된다."

        이것은 REACT 에서 좋지 않은 결과를 일으킬 수 있으니, 쓰는 작업은 지양해야한다.

8. 디바운싱 (디바운스 = 그룹화)

"디바운싱"이란, 계속해서 변경되는 state 가 있다고 생각해보자

예를들면, "id를 입력중인 상황"

유저는, 1초에 대략 5~10자 정도 되는 타자를 칠 것이다.

변경되는 state는, 유저가 키를 누를때마다 변경되고, 이는 사실 불필요한 state 의 변경일것이다.

그래서 "디바운싱"을 한다.

유저가 타자를 다 치고 나서, "1초정도 쉰다면", 그때, "state" 를 기록하는 것이다.

움직일때는 행동을 하지 않고, 움직임이 끝나면, 행동한다.

움직임을 그룹화한다. 해서 "디바운싱이다."


9. 리액트가 작동하는 방식에 대하여

    "리액트" 는 오로지 "컴포넌트" 만 신경쓴다.

        컴포넌트끼리 "props" 를 넘긴다던가 [ props 전달]
        "context" 를 사용하여, component 의 "상태를 변화"한다던가 [ wide-data ]
        component 가 "state" 변화에 의해 "재평가" 된다던가 [ internal-data ]

        이런 것들이 변화되면, "컴포넌트를 재평가" "컴포넌트"를 re-render한다.,
        화면에 표시해야 할 것이 있다면  리액트는, ReactDOM 에 그것을 알린다.

    "리액트 DOM (Virtual DOM)" 은 "REAL DOM"에게 "현재 스냅샷과 다른것"만 비교하여, "전달"한다.

    "리액트"에 의해, "비교되어 다름이 판단된 ELEMENT는" "리액트 DOM" 에게 보내지고,
    "리액트 DOM"은, REAL DOM 을 업데이트한다

    이때 "전체 REAL DOM을 re-rendering" 하는 것이 아니고, "필요한 부분(차이)만 추가, 삭제"한다.

    만약 "자식이 부모의 컴포넌트에 들어있을때" 부모컴포넌트의 State 를 바꾼다면 어떻게될까.
    "자식도 함께 재평가된다."

    [이미 자식컴포넌트는, 부모컴포넌트의 일부이기 때문이다.]

10. App.js 처럼 상위 컴포넌트가 재평가되면, 모든 하위 자식들도 전부 재평가 및 실행 된다. "낭비를 어떻게 막을 수 없을까?"

    "React.memo()" 를 사용한다.

    React.memo() 는, props 를 비교하여," props 가 변화할때만, re-render 한다"

            import React from "react"

            function Demo(props){
                    ...
            }
            export default React.memo(Demo)

11. 그럼 왜? 항상 사용하지 않는가?

    props 를 비교하는 비용이 발생하기 때문이다.

    props 를 저장, 비교 하는 "성능비용" 과, [컴포넌트를 re-render하는 성능비용] 을 비교했을때, 더 나은 쪽을 선택해야 하기 때문이다.

12. 언제 React.memo() 를 사용하는가?

    꽤나 상위 컴포넌트에 위치해서, 자식으로 있는 컴포넌트가 많을때, 

    그럼에도 불구하고, 한단계 상위 컴포넌트의 props 는 거의 고정된 채로 그곳에 보낼때,

    컴포넌트 트리가 이런 경일 경우

        A   - AB - C - D - F ...
            - AC - AD ...

    A로 부터 오는 props 가 " AB 에서는 변화가 없고",
                           " AC 에서만 변화가 대부분일 경우"
    AB 는 props 의 변화가 거의 없고, 딸린 자식들이 많기 때문에, React.memo() 를 사용하면 유용한 최적화 가 될 것이다.

            * 애초에 작은 App 은 사용할 필요가 없다.

13. React.memo() 는 "원시값의 props" 를 비교하는 데에만 적합하다.

            
        <부모>
            function App(){

                function funA(){

                }

                retrun(
                    ...
                    <DemoA props={false}/>      // 원시값 props
                    <DemoB props={funA}/>       // 참조값인 funnA 함수
                )
            }
        
        <자식 A>
                
            import React from "react"

            function DemoA(props){
                    ...
            }
            export default React.memo(Demo)

        <자식 B>

            import React from "react"

            function DemoB(props){
                    ...
            }
            export default React.memo(DemoB)


    ==> 이 경우에서는, "자식 B" 는 "re-render" 된다. "심지어 함수에서 나온 값, 식이 전부 동일함에도"

    [원시값과 참조값]

        false === false // true
        "hi" === "hi"   // true
        [1,2,3] === [1,2,3]     // ?

            정답은 false 이다.

        왜? 배열은 "참조값"이니까.

        "원시값 을 제외한 값들은 참조값을 갖는다" 대표적으로 배열, 객체 이다. 

        그리고 "함수"는 "객체"이다. (자바스크립트의 1급객체)

        그러므로, React.memo 는 "이전 함수", "현 함수" 를 비교하지만, 결국 "다르다" 라고 인식한다.

        그러므로, React.memo() 의 props 비교에는 "원시값" 으로 넣어야만 한다.
    

14. 그렇다면 "함수형"으로 props 를 넘긴다면, 어떻게, 재평가를 방지할 수 있을까?  React.memo() 에 넘기는 함수를 만들때 useCallback() 을 이용한다.

    useCallback() 은 useEffct() 와 마찬가지로 종속성이 필요한 Hook 이다.

    useCallback( 함수 , []) 를 사용하게 되면,

        함수는 마치 "한 변수에 저장 된 것처럼" 값이 같다면, 새로 생성하지 않고 "변하지 않는 메모리주소를 갖게된다".

            * 원래 안변하지만, "새로운 함수의 메모리 주소로, 새 함수를 할당하지 않는다는 말"

            A 함수를 계속 돌려쓰게된다.

    ==> 함수 생성시, useCallback() Hook 을 사용하게 되면, props 로 넘기더라도, 같은 함수를 가르킨다.

                
    <부모>
        function App(){
            const funA = useCallback(function funA(){
                console.log("funA")
            },[])

            retrun(
                ...
                <DemoB props={funA}/>       // 참조값인 funnA 함수
            )
        }

       

    <자식>
        import React from "react";

        function DemoB(props) {
            const { funA } = props;
            console.log("this is for callback");

            funA();

            return <div></div>;
            }

        export default React.memo(DemoB);


    ==> "부모" 의 "상태" 가 변하여도, "props 로 들어간 함수가 변하지 않았으므로"
            자식인 DemoB 는 "re-render" 되지 않는다.
    
15. 그렇다면 "객체나 배열" 으로 props 를 넘긴다면, 어떻게, 재평가를 방지할 수 있을까?  React.memo() 에 넘기는 함수를 만들때 useMemo() 을 이용한다.

    <사용 방법> : useCallback 과 비슷한 형태로 사용한다. 다만, 함수를 반환하기 위해, 함수형을 쓰는 것은 아니다.
                : 의존성으로, 의존되는 값을 넣어주면 된다.

            예시)
                const {item} = props
                    ...

                    useMemo(()=>{
                        return item.find(...)
                    },[item])

    <기본 사용>
        useMemo( ()=>
            return{
                "배열"
            },[])

        <부모>
            import {useMemo} from "react"

            function App(){
                const ArrayA = useMemo(()=>{
                    return [1,2,3,4,5]
                }, [])

                retrun(
                    ...
                    <DemoB props={ArrayA}/> 
                )
            }

        <자식>
            import React from "react";

            function DemoB(props) {
                cosnt {ArrayA} = props

                return <div></div>;
            }

            export default React.memo(DemoB);

        ==> 배열은 참조값이므로, 생성될때마다, 다른 메모리의 주소를 갖는다.
            그러므로, 내부 값이 같다면, 같은 메모리의 주소를 참조할 수 있도록 만들어야 하고 (위의 함수와 같이)

            그것을 위해, useMemo(()=>{},[]) 를 사용한 것이다.

            같은 값은 가진 배열을 props 를 넘겨주면, 그 값이 바뀌지 않을때, React.memo 에 의해, 
            props 가 바뀌지 않은 컴포넌트는, "재평가와 실행"이 되지 않는다.

            [최적화]

16. State 에 관하여

    : useState 는, 언제 상태를 업데이트하는가?

            function Demo(){
                const [x, setX] = useState(false)

                function change(){
                    setX(true)
                    console.log(x)
                }

            }

        => change 함수를 실행시키고 console.log() 에는 무엇이 나올까?
            "초기상태인 false 이다."

    useState 는 상태를 변화시킬때, "State 변화를 스케쥴링"한다.

    여러개의 상태 변화일 경우, A -> B -> C .. 라면

    "A 를 B 로 바꾸려는 스케쥴", "B 를 C 로 바꾸려는 스케쥴"을 "지정하고, 수행한다."

        바꾼 이후, 컴포넌트가 전부 "재평가, 실행" 되고 나서, "그 이후, State 는 업데이트된다".


    가장 흔하게 발생되는 실수를 보자면,
    
        const [enteredName, setEnteredName] = useState("before N")

        function submitHandler(){
            setEnteredName(e.target.value)

            console.log(enteredName)        // "before N"
        }

    그러므로, 훅이 포함되어있는 함수 내에서 변경된 값을 바로 사용하려면, State 가 아닌, 변수에 저장된 값을 바로 넣어주는 수 밖에 없다.

        function submitHandler(e){

            setEnteredName(e.target.value)

            console.log(e.target.value)        // "after N"
        }

17. 커스텀 훅이란?

    : 대부분의 중복되는 함수 및 중복되는 코드가 있을때, 우리는 파일 한켠에 중복되는 코드를 저장해두고 아웃소싱하는
        "리팩토링" 하게된다.

    리팩토링을 하고 싶은데, 그 안에 Hook (useState, useEffect ...) 가 들어있다면?

        "Hook 이 포함된 상태의 함수"를 리팩토링해야한다.

    이때, "Hook 을 포함하는 함수" 를 "커스텀훅" 이라 한다.

18. 훅을 리팩토링?

    <훅 사용의 유의사항>

        1. HOOK 은 반드시 "리액트 컴포넌트"안에서 사용해야한다. 
        리액트 컴포넌트 밖에 정의한 "리듀서 함수", "next의 SSR", "API" 등.. 다른곳은 안된다.

        2. HOOK 은 반드시, "컴포넌트 함수의 최상위에 사용해야한다"
        콜백 함수, 중첩 함수 같은, 하위 블록의 함수에서 사용이 불가능하다.

        3. 하나의 의존성이라도 있는 경우, "웬만하면 useEffect를 사용"한다. 또한, 의존성에 그 값을 넣는다.
            
    어? 훅은 반드시, "리액트 컴포넌트" 안에서만 사용해야한다 했다. 그런데 어떻게 "커스텀훅"을 만들지?

19. 커스텀 훅 만들기

        => 28. [커스텀 훅] 만들기 참조